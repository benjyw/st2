name: Service Examples

on:
  push:
    branches:
    - gha-service

jobs:
# Runs all steps on the VM
# The service containers will use host port binding instead of container networking so you access them via localhost rather than the service name
  mongodb-job-on-vm:  # must be a container to restart service containers.
    runs-on: ubuntu-latest

    services:
      mongodb:
        # We use bitnami to facilitate reconfiguring during the tests.
        # Many images require config in env vars (which we can't change during the test job)
        # or they require config in entrypoint args (which we can't override for GHA services)
        # bitnami builds ways to get config files from mounted volumes.
        image: bitnami/mongodb
        # MONGODB_MOUNTED_CONF_DIR defaults to /bitnami/conf (/bitnami is the MONGODB_VOLUME_DIR)
        volumes:
          - /home/runner/mongodb_conf:/bitnami/conf

        ports:
        # will assign a random free host port
        - 27017/tcp

        # These are strictly docker options, not entrypoint args (GHA restriction)
        options: >-
          --name mongodb

    steps:
    - name: backup the mongodb.conf file
      # we let root group write to this dir so that we can write to it inside the container
      run: |
        sudo chmod g+w /home/runner/mongodb_conf
        docker exec mongodb cp /opt/bitnami/mongodb/conf/mongodb.conf /bitnami/conf/mongodb.conf.orig

    - name: print job context vars
      run: echo ${MONGODB_HOST}:${MONGODB_PORT} id=${MONGODB_ID} net=${MONGODB_NETWORK}
      env:
        # use localhost for the host here because we are running the job on the VM.
        # If we were running the job on in a container this would be mongodb
        MONGODB_HOST: localhost
        MONGODB_PORT: ${{ job.services.mongodb.ports[27017] }} # get randomly assigned published port
        MONGODB_ID: ${{ job.services.mongodb.id }}
        MONGODB_NETWORK: ${{ job.services.mongodb.network }}

    - name: drop mongod.conf in /home/runner/mongodb_conf, and it will overwrite /opt/bitnami/mongodb/conf/mongod.conf
      run: |
        echo actually this will just touch example_file, not replace mongod.conf
        docker exec mongodb ls -la /opt/bitnami/mongodb/conf /bitnami/conf
        sudo touch /home/runner/mongodb_conf/example_file

    - name: restart mongodb service container (eg after changing config)
      run: docker restart mongodb

    - name: wait for mongodb
      timeout-minutes: 2
      # for a container without a HEALTHCHECK
      run: until [ "$(docker inspect -f {{.State.Running}} mongodb)" == "true" ]; do sleep 0.1; done
      # for a container with a HEALTHCHECK
      # run: until [ "$(docker inspect -f {{.State.Health.Status}} mongodb)" == "healthy" ]; do sleep 0.1; done

    - name: show the dropped example_file in /home/runner/mongodb_conf
      run: docker exec mongodb ls -la /opt/bitnami/mongodb/conf /bitnami/conf

    - name: show the mongodb.conf file
      run: docker exec mongodb cat /opt/bitnami/mongodb/conf/mongodb.conf

  # see all the comments about the mongodb image. the same applies here
  rabbitmq-job-on-vm:
    runs-on: ubuntu-latest

    services:
      rabbitmq:
        image: bitnami/rabbitmq
        volumes:
          # RABBITMQ_MOUNTED_CONF_DIR
          - /home/runner/rabbitmq_conf:/bitnami/conf

        ports:
        # these will assign a random free host port
        # These 6 ports are exposed by bitnami/rabbitmq (see https://www.rabbitmq.com/networking.html#ports)
        #- 4369/tcp  # epmd
        - 5671/tcp  # amqp w/o TLS
        - 5672/tcp  # amqp w/o TLS
        - 15671/tcp  # Management: SSL port
        - 15672/tcp  # Management: HTTP, CLI
        - 25672/tcp  # inter-node or CLI

        # These are strictly docker options, not entrypoint args (GHA restriction)
        options: >-
          --name rabbitmq

    steps:
    - name: backup the rabbitmq.conf file
      # we let root group write to this dir so that we can write to it inside the container
      run: |
        sudo chmod g+w /home/runner/rabbitmq_conf
        docker exec rabbitmq cp /opt/bitnami/rabbitmq/etc/rabbitmq/rabbitmq.conf /bitnami/conf/rabbitmq.conf.orig

    - name: print job context vars
      run: echo ${RMQ_HOST}:${RMQ_MGMNT_SSL_PORT},${RMQ_MGMNT_PORT} amqp_ports=${RMQ_AMQP_SSL_PORT},${RMQ_AMQP_PORT} cli=${RMQ_CLI_PORT} id=${RMQ_ID} net=${RMQ_NETWORK}
      env:
        RMQ_ID: ${{ job.services.rabbitmq.id }}
        RMQ_NETWORK: ${{ job.services.rabbitmq.network }}
        RMQ_HOST: localhost
        # get randomly assigned published ports
        RMQ_MGMNT_SSL_PORT: ${{ job.services.rabbitmq.ports[15671] }}
        RMQ_MGMNT_PORT: ${{ job.services.rabbitmq.ports[15672] }}
        RMQ_AMQP_SSL_PORT: ${{ job.services.rabbitmq.ports[5671] }}
        RMQ_AMQP_PORT: ${{ job.services.rabbitmq.ports[5672] }}
        RMQ_CLI_PORT: ${{ job.services.rabbitmq.ports[25672] }}

    - name: drop custom.conf in /home/runner/rabbitmq_conf, and it will be merged with /opt/bitnami/rabbitmq/etc/rabbitmq/rabbitmq.conf
      # bitnami image allows (see bitnami/rabbitmq readme):
      #   - replace generated rabbitmq.conf entirely
      #   - generate rabbitmq.conf then merge the custom.conf setings on top
      #   - add advanced.config (erlang) and/or rabbitmq-env.conf
      run: |
        docker exec rabbitmq ls -la /opt/bitnami/rabbitmq/etc/rabbitmq /bitnami/conf
        sudo touch /home/runner/rabbitmq_conf/custom.conf

    - name: restart rabbitmq service container (eg after changing config)
      run: docker restart rabbitmq

    - name: wait for rabbitmq
      timeout-minutes: 2
      # for a container without a HEALTHCHECK
      run: until [ "$(docker inspect -f {{.State.Running}} rabbitmq)" == "true" ]; do sleep 0.1; done
      # for a container with a HEALTHCHECK
      # run: until [ "$(docker inspect -f {{.State.Health.Status}} rabbitmq)" == "healthy" ]; do sleep 0.1; done

    - name: show the dropped custom.conf in /home/runner/rabbitmq_conf
      run: docker exec rabbitmq ls -la /opt/bitnami/rabbitmq/etc/rabbitmq /bitnami/conf

    - name: show the rabbitmq.conf file
      run: docker exec rabbitmq cat /opt/bitnami/rabbitmq/etc/rabbitmq/rabbitmq.conf

  # see all the comments about the mongodb image. the same applies here
  redis-job-on-vm:
    runs-on: ubuntu-latest

    services:
      redis:
        image: bitnami/redis
        volumes:
          # REDIS_MOUNTED_CONF_DIR
          - /home/runner/redis_conf:/opt/bitnami/redis/mounted-etc

        ports:
        - 6379/tcp  # these will assign a random free host port

        # These are strictly docker options, not entrypoint args (GHA restriction)
        options: >-
          --name redis

        env:
          ALLOW_EMPTY_PASSWORD: "yes"

    steps:
    - name: backup the redis.conf file
      # we let root group write to this dir so that we can write to it inside the container
      run: |
        sudo chmod g+w /home/runner/redis_conf
        docker exec redis cp /opt/bitnami/redis/etc/redis.conf /opt/bitnami/redis/mounted-etc/redis.conf.orig

    - name: print job context vars
      run: echo ${REDIS_HOST}:${REDIS_PORT} id=${REDIS_ID} net=${REDIS_NETWORK}
      env:
        REDIS_ID: ${{ job.services.redis.id }}
        REDIS_NETWORK: ${{ job.services.redis.network }}
        REDIS_HOST: localhost
        # get randomly assigned published ports
        REDIS_PORT: ${{ job.services.redis.ports[6379] }}

    - name: drop redis.conf in /home/runner/redis_conf, and it will overwrite /opt/bitnami/redis/etc/redis.conf
      run: |
        echo actually this append a comment to the end of the conf file
        docker exec redis ls -la /opt/bitnami/redis/etc /opt/bitnami/redis/mounted-etc
        tail -n 4 /home/runner/redis_conf/redis.conf.orig
        sudo cp /home/runner/redis_conf/redis.conf{.orig,}
        echo '# example update to redis.conf' | sudo tee -a /home/runner/redis_conf/redis.conf

    - name: restart redis service container (eg after changing config)
      run: docker restart redis

    - name: wait for redis
      timeout-minutes: 2
      # for a container without a HEALTHCHECK
      run: until [ "$(docker inspect -f {{.State.Running}} redis)" == "true" ]; do sleep 0.1; done
      # for a container with a HEALTHCHECK
      # run: until [ "$(docker inspect -f {{.State.Health.Status}} redis)" == "healthy" ]; do sleep 0.1; done

    - name: show the dropped redis.conf in /home/runner/redis_conf
      run: |
        docker exec redis ls -la /opt/bitnami/redis/etc /opt/bitnami/redis/mounted-etc
        docker exec redis tail -n 5 /opt/bitnami/redis/etc/redis.conf

    - name: show the redis.conf file
      run: docker exec redis cat /opt/bitnami/redis/etc/redis.conf
